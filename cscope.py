"""
    SCons tool for `cscope` command.

    The CScopeXRef() builder assumes the `cscope` command from http://cscope.sourceforge.net/.

    Ex. cscope installation for Ubuntu: `apt install cscope`

    Syntax:
        CScopeXRef('xreffile', [ target, ... ])
        CScopeXRef([ target, ... ])
        CScopeXRef([ target, ... sources, ... ])

    If omitted, the output cross-reference file name is given in $CSCOPEFILE, default 'cscope.out' in the
    source directory. Files for two additional indexes will be created by default to speed up searches:
    'csope.out.in' and 'cscope.out.po'

    The dependencies are usually other targets from your build script. Source dependencies of such targets will
    be traversed and added to the list of input files for `cscope` command.

    Each source suffix will be checked against the suffix list in env['CSCOPESUFFXIES'], and only the matching
    files are processed. You can disable the check by using the string '*' as the first list entry.

    To guarantee all symbols are visible to the `cscope` command, and listed in the resulting cross-reference file,
    the `cscope` tool should be used together with `gcc-dep`, to have full dependecy information (nested include
    files) generated by gcc / g++ compiler. Otherwise only the source dependencies visible to the SCons internal
    C/C++ scanner will be available to `cscope` command.
"""

from __future__ import print_function

import sys
import os
import re
import subprocess
import SCons.Script
import source_browse_base as base

def collect_source_dependencies(target, source, env):
    """ emitter function for CScopeXRef() builder, for listing sources of any target node included in the xref file """

    ext = os.path.splitext(str(env.File(target[0]).path)) if len(target) else ''

    if ext[1] == '.9afe1b0b-baf3-4dde-8c8f-338b120bc882':
        if len(source) and ext[0] == os.path.splitext(str(env.File(source[0]).path))[0]:
            target = [ ]
        else:
            target[0] = ext[0]  # remove automatically added extension

    getString = base.BindCallArguments(base.getString, target, source, env, None)
    getPath   = base.BindCallArguments(base.getPath,   target, source, env, None)
    getList   = base.BindCallArguments(base.getList,   target, source, env, False)
    getBool   = base.BindCallArguments(base.getBool,   target, source, env, None)

    if not len(target):
        target.append(getString('CSCOPEFILE'))

    for flag in getList('CSCOPEQUICKFLAG'):
        if flag in getList('CSCOPEFLAGS'):
            target += [ str(target[0]) + '.in', str(target[0]) + '.po' ]
            break

    if getString('CSCOPENAMEFILE'):
        target.append(getString('CSCOPENAMEFILE'))

        default_namefile = getString('CSCOPEDEFAULTNAMEFILE')

        if getString('CSCOPENAMEFILE') == default_namefile:
            env.SideEffect(default_namefile + '.8ebd1f37-538d-4d1b-a9f7-7fefa88581e4'. target)

    keepVariantDir = getBool('CSCOPEKEEPVARIANTDIR')

    return base.collect_source_dependencies(keepVariantDir, target, source, env, 'CSCOPESUFFIXES', True)

def run_cscope(target, source, env):
    """ action function invoked by the CScopeXRef() Builder to run `cscope` command """

    getList     = base.BindCallArguments(base.getList,     target, source, env, False)
    getPathList = base.BindCallArguments(base.getPathList, target, source, env, False)
    getFile     = base.BindCallArguments(base.getString,   target, source, env, lambda x: x)
    getBool     = base.BindCallArguments(base.getBool,     target, source, env, None)

    variant_dir = target[0].cwd
    cscope_dir  = variant_dir.Dir(getFile('CSCOPEDIRECTORY'))

    namefile = None

    if 'CSCOPENAMEFILE' in env:
        namefile = open(str(variant_dir.File(getFile('CSCOPENAMEFILE'))), 'w')

        nameFileFlags = getList('CSCOPENAMEFILEFLAGS')

        for arg in env.Split(env.subst("$CSCOPEFLAGS", True, target, source, lambda x: x)):
            if arg in nameFileFlags:
                namefile.write(arg)
                namefile.write('\n')

    cscope_env = env['ENV']

    env_var_list = getList('CSCOPESOURCEDIRSENV')
    inc_var_list = getList('CSCOPEINCLUDEDIRSENV')

    for env_var in env_var_list:
        if env_var and env_var in cscope_env and cscope_env[env_var]:
            source_dirs = str(cscope_env[env_var]).split(os.pathsep)

            source_dirs = \
                base.translate_include_path\
                    (
                        env, source_dirs, '.', cscope_dir, getBool('CSCOPEKEEPVARIANTDIR')
                    )
            cscope_env[env_var] = os.pathsep.join(source_dirs)

    for inc_var in inc_var_list:
        if inc_var and inc_var in cscope_env and cscope_env[inc_var]:
            inc_dirs = str(cscope_env[inc_var]).split(os.pathsep)

            inc_dirs = \
                base.translate_include_path\
                    (
                        env, inc_dirs, '.', cscope_dir, getBool('CSCOPEINCLUDEVARIANTDIR')
                    )
            cscope_env[inc_var] = os.pathsep.join(inc_dirs)

    inc_path = env.Split(env.subst("$CSCOPE_TRANSLATED_PATH", True, target, source, lambda x: x))

    if namefile is not None:
        for inc_var in inc_var_list:
            if inc_var and inc_var in cscope_env and cscope_env[inc_var]:
                for incdir in cscope_env[inc_var].split(os.pathsep):
                    if incdir not in inc_path:
                        inc_path.append(incdir)

        for incdir in  inc_path:
            for arg in getList('CSCOPEINCFLAG'):
                namefile.write(arg)
                namefile.write(' ')

            if re.search('[\s"]', incdir) is not None:
                incdir = '"' + incdir.replace('\\', '\\\\').replace('"', '\\"') + '"'

            namefile.write(incdir)
            namefile.write('\n')

    try:
        command = env.Split(env.subst("$CSCOPECOM", True, target, source, lambda x: x))

        cscope_process = \
            subprocess.Popen(command, stdin = subprocess.PIPE, env = cscope_env, cwd = str(cscope_dir))

        source.sort()
        for file in source:
            file_str = base.translate_relative_path(str(file), '.', str(cscope_dir))

            if re.search('[\s"]', file_str) is not None:
                file_str = '"' + file_str.replace('\\', '\\\\').replace('"', '\\"') + '"'

            # print("Generating xrefs for source file " + file_str)
            if namefile is not None:
                namefile.write(file_str + '\n')

            cscope_process.stdin.write(file_str + '\n')

        cscope_process.stdin.close()

        if cscope_process.wait():
            sys.stderr.write("cscope command exited with code: " + str(cscope_process.returncode) + '\n')
            return cscope_process.returncode
    finally:
        if namefile is not None:
            namefile.close()

def collect_source_directories(target, source, env):
    """ emitter function for CScopeDirXRef() builder, for listing source directories for xref file """

    ext = os.path.splitext(str(env.File(target[0]).path)) if len(target) else ''

    if ext[1] == '.8ebd1f37-538d-4d1b-a9f7-7fefa88581e4':
        if len(source) and ext[0] == os.path.splitext(str(env.File(source[0]).path))[0]:
            target = [ ]
        else:
            target[0] = ext[0]  # remove automatically added extension

    getList   = base.BindCallArguments(base.getList, target, source, env, False)
    getString = base.BindCallArguments(base.getString, target, source, env, None)
    getBool   = base.BindCallArguments(base.getBool,     target, source, env, None)

    if not target:
        target.append(getString('CSCOPEFILE'))

    for flag in getList('CSCOPEQUICKFLAG'):
        if flag in getList('CSCOPEFLAGS'):
            target += [ str(target[0]) + '.in', str(target[0]) + '.po' ]
            break

    default_namefile = getString('CSCOPEDEFAULTNAMEFILE')

    if default_namefile:
        env.SideEffect(default_namefile + '.8ebd1f37-538d-4d1b-a9f7-7fefa88581e4', target)

    # if env.Dir('.').srcnode() not in source:
    #     source = [ env.Dir('.').srcnode() ] + source

    target = env.AlwaysBuild(target)
    source = source if getBool('CSCOPEKEEPVARIANTDIR') else  [ src.srcnode() for src in source ] 

    return target, source

def run_cscope_on_dirs(target, source, env):
    """ action function invoked by the CScopeDirXRef() Builder to run `cscope` command """

    getList     = base.BindCallArguments(base.getList,     target, source, env, False)
    getPathList = base.BindCallArguments(base.getPathList, target, source, env, False)
    getString   = base.BindCallArguments(base.getString,   target, source, env, None)
    getFile     = base.BindCallArguments(base.getString,   target, source, env, lambda x: x)
    getBool     = base.BindCallArguments(base.getBool,     target, source, env, None)

    variant_dir = target[0].cwd
    cscope_dir  = variant_dir.Dir(getFile('CSCOPEDIRECTORY'))

    command = getList('CSCOPE') + getList('CSCOPEFLAGS')

    command[0] = base.translate_path_executable(command[0], str(variant_dir), str(cscope_dir), env)

    command += \
            getList('CSCOPEOUTPUTFLAG') \
                + \
            [ base.translate_relative_path(str(target[0]), '.', str(cscope_dir)) ]

    inc_path = \
        base.translate_include_path\
            (
                env,
                getPathList('CSCOPEPATH') + getPathList('CSCOPESYSPATH'),
                variant_dir,
                cscope_dir,
                getBool('CSCOPEINCLUDEVARIANTDIR')
            )

    for incdir in inc_path:
        command += getList('CSCOPEINCFLAG') + [ incdir ]

    for srcdir in source:
        command += \
                getList('CSCOPESOURCEDIRFLAG') \
                    + \
                [ base.translate_relative_path(str(srcdir), '.', str(cscope_dir)) ]

    cscope_env = env['ENV']

    env_var_list = getList('CSCOPESOURCEDIRSENV')
    inc_var_list = getList('CSCOPEINCLUDEDIRSENV')

    for env_var in env_var_list:
        if env_var and env_var in cscope_env and cscope_env[env_var]:
            source_dirs = str(cscope_env[env_var]).split(os.pathsep)

            source_dirs = \
                base.translate_include_path\
                    (
                        env, source_dirs, '.', cscope_dir, getBool('CSCOPEKEEPVARIANTDIR')
                    )
            cscope_env[env_var] = os.pathsep.join(source_dirs)

    for inc_var in inc_var_list:
        if inc_var and inc_var in cscope_env and cscope_env[inc_var]:
            inc_dirs = str(cscope_env[inc_var]).split(os.pathsep)

            inc_dirs = \
                base.translate_include_path\
                    (
                        env, inc_dirs, '.', cscope_dir, getBool('CSCOPEINCLUDEVARIANTDIR')
                    )
            cscope_env[inc_var] = os.pathsep.join(inc_dirs)

    default_namefile = str(cscope_dir.File(getFile('CSCOPEDEFAULTNAMEFILE')))

    if os.path.exists(default_namefile):
        os.rename(default_namefile, default_namefile + '.8ebd1f37-538d-4d1b-a9f7-7fefa88581e4')

    try:
        print\
            (
                '(cd ' + ' '.join(base.shell_escape([ str(cscope_dir) ]))
                       +  ' && ' + \
                ' '.join(base.shell_escape(command)) + ')'
            )

        return subprocess.Popen(command, env = cscope_env, cwd = str(cscope_dir)).wait()
    finally:
        if os.path.exists(default_namefile + '.8ebd1f37-538d-4d1b-a9f7-7fefa88581e4'):
            os.rename(default_namefile + '.8ebd1f37-538d-4d1b-a9f7-7fefa88581e4', default_namefile)

def exists(env):
    """ Check if `cscope` command is present """
    return env['CSCOPE'] if 'CSCOPE' in env else None

def show_refs_generation_message(target, source, env):
    pass

def generate(env, **kw):
    """
        Populate environment with variables for the CScopeXRef() builder:
            $CSCOPE, $CSCOPEFILE, $CSCOPEFLAGS, $CSCOPEPATH, $CSCOPEINCFLAG,
            $CSCOPESUFFIXES, $CSCOPESTDINFLAGS, $CSCOPEOUTPUTFLAG,
            $CSCOPESOURCESUFFIXES, $CSCOPERECURSIVEFLAG, $CSCOPESOURCEDIRFLAG,
            $CSCOPEDEFAULTNAMEFILE

        Attach the CScopeXRef() and CScopeDirXRef() builders to the environment.
    """

    env.SetDefault\
        (
            CSCOPE                  = [ 'cscope' ],
            CSCOPEQUICKFLAG         = [ '-q' ],
            CSCOPEFLAGS             = [ '-b', '-q', '-k' ],
            CSCOPEINCFLAG           = [ '-I' ],
            CSCOPEPATH              = lambda target, source, env, for_signature: env.get('CPPPATH', [ ]),
            CSCOPESYSPATH           = [ ],
            CSCOPESTDINFLAGS        = [ '-i', '-' ],
            CSCOPEOUTPUTFLAG        = [ '-f' ],
            CSCOPEFILE              = env.File('cscope.out').srcnode(),
            CSCOPEDIRECTORY         = env.Dir('.').srcnode(),
            CSCOPEINCLUDEVARIANTDIR = False,
            CSCOPEKEEPVARIANTDIR    = False,
            CSCOPENAMEFILE          =
                lambda target, source, env, for_signature:
                    (
                        lambda node:
                            node.File
                                (
                                    (lambda base, ext: base if ext == '.out' else base + ext)
                                        (
                                            *os.path.splitext(node.name)
                                        )
                                        +
                                    '.files'
                                )
                    )
                        (
                            env.File
                            (
                                target[0] if target else env.subst('$CSCOPEFILE', False, target, source)
                            )
                        ),
            CSCOPENAMEFILEFLAGS   = [ '-I', '-c', '-k', '-p', '-q', '-T' ],
            CSCOPESUFFIXES        =
                [
                    '',
                    '.c', '.y', '.l',
                    '.i', '.c++', '.cc', '.cp', '.cpp', '.cxx', '.C',
                    '.h', '.h++', '.hh', '.hp', '.hpp', '.hxx', '.H', '.tcc',
                ],
            CSCOPESOURCESUFFIXES  =
                [
                    '.c', '.y', '.l', '.i', '.c++', '.cc', '.cp', 'cpp', '.C'
                ],
            CSCOPERECURSIVEFLAG   = [ '-R' ],
            CSCOPESOURCEDIRFLAG   = [ '-s' ],
            CSCOPEDEFAULTNAMEFILE = 'cscope.files',
            CSCOPESOURCEDIRSENV   = [ 'SOURCEDIRS' ],
            CSCOPEINCLUDEDIRSENV  = [ 'INCLUDEDIRS' ],
            CSCOPELISTINCLUDES    =
                lambda target, source, env, for_signature:
                    [
                        env['CSCOPEINCFLAG']
                            +
                        [
                            path if re.search('[\s' + re.escape(']&*?\'"!?[|)(;><]') + ']', path) is None
                                else env.ESCAPE(path)
                        ]
                            for path_variable in [ 'CSCOPEPATH', 'CSCOPESYSPATH' ]
                                for path in base.getPathList(target, source, env, None, path_variable)
                    ],

            CSCOPELISTINPUT       =
                lambda target, source, env, for_signature:
                    '\n'.join\
                        (
                            [
                                arg if re.search('[\s"]', arg) is None
                                    else arg.replace('\\', '\\\\').replace('"', '\\"')
                                    for arg in sorted([ str(src) for src in source ])
                            ]
                        ),

            CSCOPE_TRANSLATED_CMD =
                lambda target, source, env, for_signature:
                    [
                        base.translate_path_executable
                            (
                                str(env.Split(env.subst("$CSCOPE", True, target, source, lambda x: x))[0]),
                                str(target[0].cwd),
                                str(target[0].cwd.Dir(env.subst('$CSCOPEDIRECTORY', True, target, source, lambda x: x))),
                                env
                            )
                    ] \
                        + \
                    env.Split(env.subst("$CSCOPE", True, target, source, lambda x: x))[1:],

            CSCOPE_TRANSLATED_TARGET =
                lambda target, source, env, for_signature:
                    base.translate_relative_path\
                        (
                            str(target[0]),
                            '.',
                            str(target[0].cwd.Dir(env.subst('$CSCOPEDIRECTORY', True, target, source, lambda x: x)))
                        ),

            CSCOPE_TRANSLATED_PATH =
                lambda target, source, env, for_signature:
                    base.translate_include_path\
                        (
                            env,
                            env.Split(env.subst('$CSCOPEPATH',    True, target, source, lambda x: x))
                                +
                            env.Split(env.subst('$CSCOPESYSPATH', True, target, source, lambda x: x)),
                            target[0].cwd,
                            target[0].cwd.Dir(env.subst('$CSCOPEDIRECTORY', True, target, source, lambda x: x)),
                            env.subst('$CSCOPEINCLUDEVARIANTDIR', True, target, source, lambda x: not not x)
                        ),

            CSCOPE_TRANSLATED_INC =
                lambda target, source, env, for_signature:
                    [
                        arg
                            for incdir in \
                                    env.Split(env.subst('$CSCOPE_TRANSLATED_PATH', True, target, source, lambda x: x))
                                for arg in \
                                        env.Split(env.subst('$CSCOPEINCFLAG', True, target, source, lambda x: x)) \
                                            + \
                                        [ incdir ]
                    ],

            CSCOPECOM              =
                lambda target, source, env, for_signature:
                    env.Split(env.subst("$CSCOPE_TRANSLATED_CMD", True, target, source, lambda x: x)) \
                        + \
                    env.Split(env.subst("$CSCOPEFLAGS",           True, target, source, lambda x: x)) \
                        + \
                    env.Split(env.subst("$CSCOPESTDINFLAGS",      True, target, source, lambda x: x)) \
                        + \
                    env.Split(env.subst("$CSCOPEOUTPUTFLAG",      True, target, source, lambda x: x)) \
                        + \
                    [ env.subst("$CSCOPE_TRANSLATED_TARGET",      True, target, source, lambda x: x) ] \
                        +
                    env.Split(env.subst("$CSCOPE_TRANSLATED_INC", True, target, source, lambda x: x)),

            CSCOPECOM_QUOTED      =
                lambda target, source, env, for_signature:
                    base.env_shell_escape(env, env.Split(env.subst("$CSCOPECOM", True, target, source, lambda x: x))),

            CSCOPESHOWINPUT       = False,
            CSCOPECOMSTR          =
                "(cd $CSCOPEDIRECTORY && $CSCOPECOM_QUOTED"
                    +
                '${CSCOPESHOWINPUT and " <<\'-- END OF NAMEFILE\'" + chr(10)    or ""}'
                '${CSCOPESHOWINPUT and CSCOPELISTINPUT                          or ""}'
                '${CSCOPESHOWINPUT and chr(10) + "-- END OF NAMEFILE" + chr(10) or ""}'
                ')'
        )

    env['BUILDERS']['CScopeXRef'] = env.Builder\
            (
                emitter = collect_source_dependencies,
                action  = SCons.Script.Action(run_cscope, '$CSCOPECOMSTR'),
                multi   = True,
                name    = 'CScopeXRef',
                suffix  = '9afe1b0b-baf3-4dde-8c8f-338b120bc882',
                # source_scanner = SCons.Script.CScan
            )

    env['BUILDERS']['CScopeDirXRef'] = env.Builder\
            (
                emitter         = collect_source_directories,
                action          = SCons.Script.Action(run_cscope_on_dirs, show_refs_generation_message),
                multi           = True,
                name            = 'CScopeDirXRef',
                suffix          = '8ebd1f37-538d-4d1b-a9f7-7fefa88581e4',
                source_factory  = SCons.Script.Dir
            )

    # env.AddMethod(base.test_get_generated_list)
    env['XREF_GENERATED_LIST'] = \
            lambda generator, *generator_args: base.generated_list(generator, *generator_args)

